plugins{
    id 'java-library'
}

def generatedSourcesDir = file("$buildDir/generated/sources")

sourceSets.main{
    java.srcDirs = [
            'src/',
            "${generatedSourcesDir}/fetchComps/java/main"
    ]
}

dependencies{
    compileOnly "org.jetbrains:annotations:24.0.1"
    compileOnly "com.github.Anuken.Arc:arc-core:$arcVersion"
    compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"
    compileOnly project(':annotations')
    annotationProcessor project(':annotations')
    annotationProcessor "com.github.Anuken:jabel:$jabelVersion"
}

ext{
    fetchPackage = modName.replaceAll("-", "") + '/fetched'
    fetchDir = file("${generatedSourcesDir}/fetchComps/java/main/$fetchPackage")
    fetchTemp = file("${generatedSourcesDir}/fetchComps/fetch.txt")
    fetchRevision = 0
}


import arc.files.Fi
import arc.struct.Seq
import arc.util.Http
import arc.util.Log
import arc.util.OS
import arc.util.UnsafeRunnable
import arc.util.serialization.Jval

import java.util.concurrent.CopyOnWriteArrayList

task deploy(type: Jar, dependsOn: configurations.runtimeClasspath){
    dependsOn ':tools:proc'

    archiveFileName.set "${modDisplayName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect{ it.isDirectory() ? it : zipTree(it) }
    from files(assetsDir){ exclude 'sprites/vanilla/**' }

    from(rootDir){
        include 'mod.json'
        include 'icon.png'
    }
}

task dex(type: Jar){
    archiveFileName.set "${modDisplayName}.jar"
    dependsOn deploy

    final def desktopJar = deploy.archiveFile.get().asFile
    final def dexJar = new File(dex.temporaryDir, 'Dexed.jar')

    doFirst{
        def command = ['d8', '--min-api', sdkAPI, '--output', dexJar, desktopJar]
        final File[] files =
                configurations.compileClasspath.asList() +
                        configurations.runtimeClasspath.asList()

        for(def file : files) command += ['--classpath', file.path]
        command += ['--lib', file("$sdkRoot/platforms/android-$sdkVersion/android.jar")]

        if(OS.isWindows) command = ['cmd', '/c'] + command
        command.join(' ').execute(null, new File("$buildDir/libs")).waitForProcessOutput(System.out, System.err)
    }

    from zipTree(desktopJar)
    from zipTree(dexJar)
}

class Fetcher{
    UnsafeRunnable run
    private volatile Throwable error = null

    @SuppressWarnings('all')
    void execute(){
        try{
            run.run()
            error = null
        }catch(Throwable e){
            Log.err(e)
            error = e
        }
    }
}

task fetchComps{
    inputs.property "mindustryVersion", mindustryFetchVersion
    inputs.property "fetchRevision", fetchRevision
    outputs.dir fetchDir
    outputs.file fetchTemp

    doLast{
        delete{ delete fetchDir.parentFile.parentFile }
        fetchDir.mkdirs()

        final CopyOnWriteArrayList<Fetcher> fetches = new CopyOnWriteArrayList<>()

        UnsafeRunnable mainRun = {
            Http.get("https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryFetchVersion")
                    .error({ final t -> throw new RuntimeException(t) })
                    .block({ final res ->
                        final def list = Jval.read(res.getResultAsString()).asArray()

                        for(final Jval val : list){
                            final def filename = val.get('name').asString()
                            final def fileurl = val.get('download_url').asString()

                            final UnsafeRunnable run = {
                                Http.get(fileurl)
                                        .error({ final t -> throw new RuntimeException(t) })
                                        .block({ final comp ->
                                            final def content = comp.getResultAsString()
                                                    .replace('mindustry.entities.comp', fetchPackage.replace('/', '.'))
                                                    .replace('mindustry.annotations.Annotations.*', modName + '.annotations.Annotations.*')
                                                    .replaceAll('@Component\\((base = true|.)+\\)\\n*', '@EntityComponent(base = true, write = false)\n')
                                                    .replaceAll('@Component\\n*', '@EntityComponent(write = false)\n')
                                                    .replaceAll('@BaseComponent\\n*', '@EntityBaseComponent\n')
                                                    .replaceAll('@CallSuper\\n*', '')
                                                    .replaceAll('@Final\\n*', '')
                                                    .replaceAll('@EntityDef\\(*.*\\)*\\n*', '')
                                                    .replaceAll('@MethodPriority\\(([^)]+)f\\)', '@MethodPriority($1)')

                                            if(content.isEmpty()) throw new IllegalStateException()

                                            final def fi = Fi.get("$fetchDir/$filename")
                                            fi.writeString(content, false)
                                        })
                            }
                            fetches.add(new Fetcher(run: run))
                        }
                    })
        }

        new Fetcher(run: mainRun).execute()

        final def found = fetches.size()
        Seq<Thread> threads = Seq.with(fetches).map({ final Fetcher fetch ->
            new Thread({
                fetch.execute()
                synchronized(fetches){
                    fetches.remove(fetch)
                }
            })
        })

        threads.each(Thread::start)
        while(!fetches.isEmpty()) Thread.currentThread().yield()

        fetchTemp.text = "$mindustryVersion/$fetchRevision"
    }
}

tasks.withType(JavaCompile).configureEach{ task ->
    task.dependsOn 'fetchComps'
}

tasks.withType(Jar){
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    exclude modName + '/fetched/**'
    exclude modName + '/entities/comp/**'
    exclude modName + '/entities/merge/**'

    exclude 'sprites/vanilla/**'
}
