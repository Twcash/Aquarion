sourceSets.main{
    java.srcDirs = ['src/']
}

import arc.files.*
import arc.func.Func2
import arc.struct.IntMap
import arc.struct.ObjectMap
import arc.struct.OrderedMap
import arc.struct.Seq
import arc.util.Log
import arc.util.io.PropertiesUtils

dependencies{
    implementation project(':main')
    compileOnly project(':annotations')
    annotationProcessor project(':annotations')
    implementation "com.github.Anuken.Arc:arc-core:$arcVersion"
    implementation "com.github.Anuken.Mindustry:core:$mindustryVersion"
}

task proc(dependsOn: [classes, configurations.runtimeClasspath]){

    doLast{
        delete{ delete spritesDir }
        spritesDir.mkdirs()

        copy{
            from spritesRawDir
            into spritesDir
        }

        javaexec{
            workingDir = assetsDir
            main = rootProject.ext.modName.replaceAll("-", "") + '.tools.Tools'
            classpath = sourceSets.main.runtimeClasspath
            systemProperty 'currentModName', modName
        }
    }
}

task updateBundles{
    doLast{
        def uniEscape = { String string ->
            StringBuilder outBuffer = new StringBuilder()
            int len = string.length()
            for(int i = 0; i < len; i++){
                char ch = string.charAt(i)
                if((ch > 61) && (ch < 127)){
                    outBuffer.append(ch == (char)'\\' ? "\\" : ch)
                    continue
                }

                if(ch >= 0xE000 && ch <= 0xF8FF){
                    String hex = Integer.toHexString((int)ch)
                    outBuffer.append("\\u")
                    for(int j = 0; j < 4 - hex.length(); j++){
                        outBuffer.append('0')
                    }
                    outBuffer.append(hex)
                }else{
                    outBuffer.append(ch)
                }
            }

            return outBuffer.toString()
        }

        OrderedMap<String, String> base = new OrderedMap<>()
        PropertiesUtils.load(base, Fi.get("main/assets/bundles/bundle.properties").reader())

        IntMap<String> commentAndBlankLines = new IntMap<>()
        var lines = Fi.get("main/assets/bundles/bundle.properties").reader().readLines()
        int offset = 0
        for(int i = 0; i < lines.size(); i++){
            var line = lines.get(i)
            if(i > 0 && lines.get(i - 1).endsWith("\\")) offset++
            else if(line.isEmpty() || line.startsWith("#")) commentAndBlankLines.put(i - offset, line)
        }

        Fi.get("main/assets/bundles").walk(child -> {
            if(child.name() == "bundle.properties" || child.toString().contains("output")) return
            if(project.hasProperty("bundle") && child.name() != project.property("bundle")) return

            OrderedMap<String, String> other = new OrderedMap<>()
            ObjectMap<String, String> extras = new ObjectMap<>()
            Seq<String> removals = new Seq<>()
            PropertiesUtils.load(other, child.reader())

            for(String key : other.orderedKeys()){
                if(!base.containsKey(key) && key.contains(".details") && false){
                    extras.put(key, other.get(key))
                }else if(!base.containsKey(key)){
                    removals.add(key)
                }
            }
            for(String s : removals){
                other.remove(s)
            }

            for(String key : base.orderedKeys()){
                if(other.get(key) == null || other.get(key).trim().isEmpty()){
                    other.put(key, base.get(key))
                }
            }

            Func2<String, String, String> processor = (key, value) ->
                    (key + " =" + (value.trim().isEmpty() ? "" : " ") + uniEscape(value)).replace("\n", "\\n") + "\n"

            StringBuilder result = new StringBuilder()
            int i = 0
            for(String key : base.orderedKeys().copy().add(extras.keys().toSeq())){
                while(commentAndBlankLines.containsKey(i++)) result.append(commentAndBlankLines.get(i - 1) + "\n")
                if(other.get(key) == null) continue
                result.append(processor.get(key, other.get(key)))
                other.remove(key)
            }

            child.writeString(result.toString())
        })
    }
}